/// THIS IS A GENERATED FILE. DO NOT MODIFY MANUALLY.
///
/// This file was auto generated by rindexer - https://github.com/joshstevens19/rindexer.
/// Any manual changes to this file will be overwritten.
use alloy::{primitives::U64, transports::http::reqwest::header::HeaderMap};
use rindexer::{
    lazy_static,
    manifest::network::{AddressFiltering, BlockPollFrequency},
    notifications::ChainStateNotification,
    provider::{create_client, JsonRpcCachedProvider, RetryClientError, RindexerProvider},
    public_read_env_value,
    reth::node::start_reth_node_with_exex,
};
use std::sync::Arc;
use tokio::sync::broadcast::Sender;
use tokio::sync::OnceCell;

#[allow(dead_code)]
async fn create_shadow_client(
    rpc_url: &str,
    chain_id: u64,
    compute_units_per_second: Option<u64>,
    block_poll_frequency: Option<BlockPollFrequency>,
    max_block_range: Option<U64>,
    address_filtering: Option<AddressFiltering>,
    chain_state_notification: Option<Sender<ChainStateNotification>>,
) -> Result<Arc<JsonRpcCachedProvider>, RetryClientError> {
    let mut header = HeaderMap::new();
    header.insert(
        "X-SHADOW-API-KEY",
        public_read_env_value("RINDEXER_PHANTOM_API_KEY").unwrap().parse().unwrap(),
    );
    create_client(
        rpc_url,
        chain_id,
        compute_units_per_second,
        max_block_range,
        block_poll_frequency,
        header,
        address_filtering,
        chain_state_notification,
    )
    .await
}

static ETHEREUM_PROVIDER: OnceCell<Arc<JsonRpcCachedProvider>> = OnceCell::const_new();

static BASE_PROVIDER: OnceCell<Arc<JsonRpcCachedProvider>> = OnceCell::const_new();

pub async fn get_ethereum_provider_cache() -> Arc<JsonRpcCachedProvider> {
    ETHEREUM_PROVIDER
        .get_or_init(|| async {
            let chain_state_notification = None;

            create_client(
                &public_read_env_value("https://mainnet.gateway.tenderly.co")
                    .unwrap_or("https://mainnet.gateway.tenderly.co".to_string()),
                1,
                None,
                None,
                Some(BlockPollFrequency::Division { divisor: 4 }),
                HeaderMap::new(),
                None,
                chain_state_notification,
            )
            .await
            .expect("Error creating provider")
        })
        .await
        .clone()
}

pub async fn get_ethereum_provider() -> Arc<RindexerProvider> {
    get_ethereum_provider_cache().await.get_inner_provider()
}

pub async fn get_base_provider_cache() -> Arc<JsonRpcCachedProvider> {
    BASE_PROVIDER
        .get_or_init(|| async {
            let chain_state_notification = None;

            create_client(
                &public_read_env_value("https://mainnet.base.org")
                    .unwrap_or("https://mainnet.base.org".to_string()),
                8453,
                None,
                None,
                None,
                HeaderMap::new(),
                None,
                chain_state_notification,
            )
            .await
            .expect("Error creating provider")
        })
        .await
        .clone()
}

pub async fn get_base_provider() -> Arc<RindexerProvider> {
    get_base_provider_cache().await.get_inner_provider()
}

pub async fn get_provider_cache_for_network(network: &str) -> Arc<JsonRpcCachedProvider> {
    if network == "ethereum" {
        return get_ethereum_provider_cache().await;
    }

    if network == "base" {
        return get_base_provider_cache().await;
    }
    panic!("Network not supported")
}
