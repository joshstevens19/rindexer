#![allow(
    non_camel_case_types,
    clippy::enum_variant_names,
    clippy::too_many_arguments,
    clippy::upper_case_acronyms,
    clippy::type_complexity,
    dead_code
)]
use super::super::super::super::typings::database::get_or_init_postgres_client;
use super::super::super::super::typings::networks::get_provider_cache_for_network;
/// THIS IS A GENERATED FILE. DO NOT MODIFY MANUALLY.
///
/// This file was auto generated by rindexer - https://github.com/joshstevens19/rindexer.
/// Any manual changes to this file will be overwritten.
use super::playground_types_abi_gen::RindexerPlaygroundTypesGen::{
    self, RindexerPlaygroundTypesGenEvents, RindexerPlaygroundTypesGenInstance,
};
use alloy::network::AnyNetwork;
use alloy::primitives::{Address, B256, Bytes};
use alloy::sol_types::{SolEvent, SolEventInterface, SolType};
use rindexer::{
    AsyncCsvAppender, FutureExt, PostgresClient, async_trait,
    event::{
        callback_registry::{
            EventCallbackRegistry, EventCallbackRegistryInformation, EventCallbackResult,
            EventResult, HasTxInformation, TxInformation,
        },
        contract_setup::{ContractInformation, NetworkContract},
    },
    generate_random_id,
    manifest::{
        contract::{Contract, ContractDetails},
        yaml::read_manifest,
    },
    provider::{JsonRpcCachedProvider, RindexerProvider},
};
use std::collections::HashMap;
use std::error::Error;
use std::future::Future;
use std::path::{Path, PathBuf};
use std::pin::Pin;
use std::{any::Any, sync::Arc};

pub type BasicTypesData = RindexerPlaygroundTypesGen::BasicTypes;

#[derive(Debug, Clone)]
pub struct BasicTypesResult {
    pub event_data: BasicTypesData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for BasicTypesResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type BytesTypesData = RindexerPlaygroundTypesGen::BytesTypes;

#[derive(Debug, Clone)]
pub struct BytesTypesResult {
    pub event_data: BytesTypesData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for BytesTypesResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type RegularWidthSignedIntegersData = RindexerPlaygroundTypesGen::RegularWidthSignedIntegers;

#[derive(Debug, Clone)]
pub struct RegularWidthSignedIntegersResult {
    pub event_data: RegularWidthSignedIntegersData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for RegularWidthSignedIntegersResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type RegularWidthUnsignedIntegersData =
    RindexerPlaygroundTypesGen::RegularWidthUnsignedIntegers;

#[derive(Debug, Clone)]
pub struct RegularWidthUnsignedIntegersResult {
    pub event_data: RegularWidthUnsignedIntegersData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for RegularWidthUnsignedIntegersResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type IrregularWidthSignedIntegersData =
    RindexerPlaygroundTypesGen::IrregularWidthSignedIntegers;

#[derive(Debug, Clone)]
pub struct IrregularWidthSignedIntegersResult {
    pub event_data: IrregularWidthSignedIntegersData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for IrregularWidthSignedIntegersResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type IrregularWidthUnsignedIntegersData =
    RindexerPlaygroundTypesGen::IrregularWidthUnsignedIntegers;

#[derive(Debug, Clone)]
pub struct IrregularWidthUnsignedIntegersResult {
    pub event_data: IrregularWidthUnsignedIntegersData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for IrregularWidthUnsignedIntegersResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type Under_ScoreData = RindexerPlaygroundTypesGen::Under_Score;

#[derive(Debug, Clone)]
pub struct Under_ScoreResult {
    pub event_data: Under_ScoreData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for Under_ScoreResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

pub type CAPITALIZEDData = RindexerPlaygroundTypesGen::CAPITALIZED;

#[derive(Debug, Clone)]
pub struct CAPITALIZEDResult {
    pub event_data: CAPITALIZEDData,
    pub tx_information: TxInformation,
}

impl HasTxInformation for CAPITALIZEDResult {
    fn tx_information(&self) -> &TxInformation {
        &self.tx_information
    }
}

type BoxFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;

#[async_trait]
trait EventCallback {
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()>;
}

pub struct EventContext<TExtensions>
where
    TExtensions: Send + Sync,
{
    pub database: Arc<PostgresClient>,
    pub csv: Arc<AsyncCsvAppender>,
    pub extensions: Arc<TExtensions>,
}

// didn't want to use option or none made harder DX
// so a blank struct makes interface nice
pub struct NoExtensions {}
pub fn no_extensions() -> NoExtensions {
    NoExtensions {}
}

pub fn basictypes_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> BasicTypesEventCallbackType<TExtensions>
where
    BasicTypesResult: Clone + 'static,
    F: for<'a> Fn(Vec<BasicTypesResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type BasicTypesEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<BasicTypesResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct BasicTypesEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: BasicTypesEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> BasicTypesEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        BasicTypesResult: Clone + 'static,
        F: for<'a> Fn(Vec<BasicTypesResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-basictypes.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-basictypes.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "a_bool".into(), "simple_address".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: basictypes_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for BasicTypesEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<BasicTypesResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<BasicTypesData>().ok().map(|arc| BasicTypesResult {
                    event_data: (*arc).clone(),
                    tx_information: item.tx_information,
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("BasicTypesEvent: Unexpected data type - expected: BasicTypesData")
        }
    }
}

pub fn bytestypes_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> BytesTypesEventCallbackType<TExtensions>
where
    BytesTypesResult: Clone + 'static,
    F: for<'a> Fn(Vec<BytesTypesResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type BytesTypesEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<BytesTypesResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct BytesTypesEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: BytesTypesEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> BytesTypesEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        BytesTypesResult: Clone + 'static,
        F: for<'a> Fn(Vec<BytesTypesResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-bytestypes.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-bytestypes.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "a_byte_1".into(), "a_byte_4".into(), "a_byte_8".into(), "a_byte_16".into(), "a_byte_32".into(), "dynamic_bytes".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: bytestypes_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for BytesTypesEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<BytesTypesResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<BytesTypesData>().ok().map(|arc| BytesTypesResult {
                    event_data: (*arc).clone(),
                    tx_information: item.tx_information,
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("BytesTypesEvent: Unexpected data type - expected: BytesTypesData")
        }
    }
}

pub fn regularwidthsignedintegers_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> RegularWidthSignedIntegersEventCallbackType<TExtensions>
where
    RegularWidthSignedIntegersResult: Clone + 'static,
    F: for<'a> Fn(Vec<RegularWidthSignedIntegersResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type RegularWidthSignedIntegersEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<RegularWidthSignedIntegersResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct RegularWidthSignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: RegularWidthSignedIntegersEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> RegularWidthSignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        RegularWidthSignedIntegersResult: Clone + 'static,
        F: for<'a> Fn(Vec<RegularWidthSignedIntegersResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-regularwidthsignedintegers.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-regularwidthsignedintegers.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "i_8".into(), "i_16".into(), "i_32".into(), "i_64".into(), "i_128".into(), "i_256".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: regularwidthsignedintegers_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for RegularWidthSignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<RegularWidthSignedIntegersResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<RegularWidthSignedIntegersData>().ok().map(|arc| {
                    RegularWidthSignedIntegersResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    }
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!(
                "RegularWidthSignedIntegersEvent: Unexpected data type - expected: RegularWidthSignedIntegersData"
            )
        }
    }
}

pub fn regularwidthunsignedintegers_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> RegularWidthUnsignedIntegersEventCallbackType<TExtensions>
where
    RegularWidthUnsignedIntegersResult: Clone + 'static,
    F: for<'a> Fn(Vec<RegularWidthUnsignedIntegersResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type RegularWidthUnsignedIntegersEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<RegularWidthUnsignedIntegersResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct RegularWidthUnsignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: RegularWidthUnsignedIntegersEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> RegularWidthUnsignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        RegularWidthUnsignedIntegersResult: Clone + 'static,
        F: for<'a> Fn(
                Vec<RegularWidthUnsignedIntegersResult>,
                Arc<EventContext<TExtensions>>,
            ) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-regularwidthunsignedintegers.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-regularwidthunsignedintegers.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "u_8".into(), "u_16".into(), "u_32".into(), "u_64".into(), "u_128".into(), "u_256".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: regularwidthunsignedintegers_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for RegularWidthUnsignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<RegularWidthUnsignedIntegersResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<RegularWidthUnsignedIntegersData>().ok().map(|arc| {
                    RegularWidthUnsignedIntegersResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    }
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!(
                "RegularWidthUnsignedIntegersEvent: Unexpected data type - expected: RegularWidthUnsignedIntegersData"
            )
        }
    }
}

pub fn irregularwidthsignedintegers_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> IrregularWidthSignedIntegersEventCallbackType<TExtensions>
where
    IrregularWidthSignedIntegersResult: Clone + 'static,
    F: for<'a> Fn(Vec<IrregularWidthSignedIntegersResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type IrregularWidthSignedIntegersEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<IrregularWidthSignedIntegersResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct IrregularWidthSignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: IrregularWidthSignedIntegersEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> IrregularWidthSignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        IrregularWidthSignedIntegersResult: Clone + 'static,
        F: for<'a> Fn(
                Vec<IrregularWidthSignedIntegersResult>,
                Arc<EventContext<TExtensions>>,
            ) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-irregularwidthsignedintegers.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-irregularwidthsignedintegers.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "i_24".into(), "i_40".into(), "i_48".into(), "i_56".into(), "i_72".into(), "i_80".into(), "i_88".into(), "i_96".into(), "i_104".into(), "i_112".into(), "i_120".into(), "i_136".into(), "i_144".into(), "i_152".into(), "i_160".into(), "i_168".into(), "i_176".into(), "i_184".into(), "i_192".into(), "i_200".into(), "i_208".into(), "i_216".into(), "i_224".into(), "i_232".into(), "i_240".into(), "i_248".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: irregularwidthsignedintegers_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for IrregularWidthSignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<IrregularWidthSignedIntegersResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<IrregularWidthSignedIntegersData>().ok().map(|arc| {
                    IrregularWidthSignedIntegersResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    }
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!(
                "IrregularWidthSignedIntegersEvent: Unexpected data type - expected: IrregularWidthSignedIntegersData"
            )
        }
    }
}

pub fn irregularwidthunsignedintegers_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> IrregularWidthUnsignedIntegersEventCallbackType<TExtensions>
where
    IrregularWidthUnsignedIntegersResult: Clone + 'static,
    F: for<'a> Fn(Vec<IrregularWidthUnsignedIntegersResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type IrregularWidthUnsignedIntegersEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<IrregularWidthUnsignedIntegersResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct IrregularWidthUnsignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: IrregularWidthUnsignedIntegersEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> IrregularWidthUnsignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        IrregularWidthUnsignedIntegersResult: Clone + 'static,
        F: for<'a> Fn(
                Vec<IrregularWidthUnsignedIntegersResult>,
                Arc<EventContext<TExtensions>>,
            ) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-irregularwidthunsignedintegers.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-irregularwidthunsignedintegers.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "u_24".into(), "u_40".into(), "u_48".into(), "u_56".into(), "u_72".into(), "u_80".into(), "u_88".into(), "u_96".into(), "u_104".into(), "u_112".into(), "u_120".into(), "u_136".into(), "u_144".into(), "u_152".into(), "u_160".into(), "u_168".into(), "u_176".into(), "u_184".into(), "u_192".into(), "u_200".into(), "u_208".into(), "u_216".into(), "u_224".into(), "u_232".into(), "u_240".into(), "u_248".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: irregularwidthunsignedintegers_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for IrregularWidthUnsignedIntegersEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<IrregularWidthUnsignedIntegersResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<IrregularWidthUnsignedIntegersData>().ok().map(|arc| {
                    IrregularWidthUnsignedIntegersResult {
                        event_data: (*arc).clone(),
                        tx_information: item.tx_information,
                    }
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!(
                "IrregularWidthUnsignedIntegersEvent: Unexpected data type - expected: IrregularWidthUnsignedIntegersData"
            )
        }
    }
}

pub fn under_score_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> Under_ScoreEventCallbackType<TExtensions>
where
    Under_ScoreResult: Clone + 'static,
    F: for<'a> Fn(Vec<Under_ScoreResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type Under_ScoreEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<Under_ScoreResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct Under_ScoreEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: Under_ScoreEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> Under_ScoreEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        Under_ScoreResult: Clone + 'static,
        F: for<'a> Fn(Vec<Under_ScoreResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-under_score.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-under_score.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "foo".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: under_score_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for Under_ScoreEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<Under_ScoreResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<Under_ScoreData>().ok().map(|arc| Under_ScoreResult {
                    event_data: (*arc).clone(),
                    tx_information: item.tx_information,
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("Under_ScoreEvent: Unexpected data type - expected: Under_ScoreData")
        }
    }
}

pub fn capitalized_handler<TExtensions, F, Fut>(
    custom_logic: F,
) -> CAPITALIZEDEventCallbackType<TExtensions>
where
    CAPITALIZEDResult: Clone + 'static,
    F: for<'a> Fn(Vec<CAPITALIZEDResult>, Arc<EventContext<TExtensions>>) -> Fut
        + Send
        + Sync
        + 'static
        + Clone,
    Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    TExtensions: Send + Sync + 'static,
{
    Arc::new(move |results, context| {
        let custom_logic = custom_logic.clone();
        let results = results.clone();
        let context = Arc::clone(&context);
        async move { (custom_logic)(results, context).await }.boxed()
    })
}

type CAPITALIZEDEventCallbackType<TExtensions> = Arc<
    dyn for<'a> Fn(
            &'a Vec<CAPITALIZEDResult>,
            Arc<EventContext<TExtensions>>,
        ) -> BoxFuture<'a, EventCallbackResult<()>>
        + Send
        + Sync,
>;

pub struct CAPITALIZEDEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    callback: CAPITALIZEDEventCallbackType<TExtensions>,
    context: Arc<EventContext<TExtensions>>,
}

impl<TExtensions> CAPITALIZEDEvent<TExtensions>
where
    TExtensions: Send + Sync + 'static,
{
    pub async fn handler<F, Fut>(closure: F, extensions: TExtensions) -> Self
    where
        CAPITALIZEDResult: Clone + 'static,
        F: for<'a> Fn(Vec<CAPITALIZEDResult>, Arc<EventContext<TExtensions>>) -> Fut
            + Send
            + Sync
            + 'static
            + Clone,
        Fut: Future<Output = EventCallbackResult<()>> + Send + 'static,
    {
        let csv = AsyncCsvAppender::new(
            r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-capitalized.csv",
        );
        if !Path::new(r"/Users/pawellula/RustroverProjects/rindexer/cli/../rindexer_rust_playground/generated_csv/PlaygroundTypes/playgroundtypes-capitalized.csv").exists() {
            csv.append_header(vec!["contract_address".into(), "foo".into(), "tx_hash".into(), "block_number".into(), "block_hash".into(), "network".into(), "tx_index".into(), "log_index".into()].into())
                .await
                .expect("Failed to write CSV header");
        }

        Self {
            callback: capitalized_handler(closure),
            context: Arc::new(EventContext {
                database: get_or_init_postgres_client().await,
                csv: Arc::new(csv),
                extensions: Arc::new(extensions),
            }),
        }
    }
}

#[async_trait]
impl<TExtensions> EventCallback for CAPITALIZEDEvent<TExtensions>
where
    TExtensions: Send + Sync,
{
    async fn call(&self, events: Vec<EventResult>) -> EventCallbackResult<()> {
        let events_len = events.len();

        // note some can not downcast because it cant decode
        // this happens on events which failed decoding due to
        // not having the right abi for example
        // transfer events with 2 indexed topics cant decode
        // transfer events with 3 indexed topics
        let result: Vec<CAPITALIZEDResult> = events
            .into_iter()
            .filter_map(|item| {
                item.decoded_data.downcast::<CAPITALIZEDData>().ok().map(|arc| CAPITALIZEDResult {
                    event_data: (*arc).clone(),
                    tx_information: item.tx_information,
                })
            })
            .collect();

        if result.len() == events_len {
            (self.callback)(&result, Arc::clone(&self.context)).await
        } else {
            panic!("CAPITALIZEDEvent: Unexpected data type - expected: CAPITALIZEDData")
        }
    }
}

pub enum PlaygroundTypesEventType<TExtensions>
where
    TExtensions: 'static + Send + Sync,
{
    BasicTypes(BasicTypesEvent<TExtensions>),
    BytesTypes(BytesTypesEvent<TExtensions>),
    RegularWidthSignedIntegers(RegularWidthSignedIntegersEvent<TExtensions>),
    RegularWidthUnsignedIntegers(RegularWidthUnsignedIntegersEvent<TExtensions>),
    IrregularWidthSignedIntegers(IrregularWidthSignedIntegersEvent<TExtensions>),
    IrregularWidthUnsignedIntegers(IrregularWidthUnsignedIntegersEvent<TExtensions>),
    Under_Score(Under_ScoreEvent<TExtensions>),
    CAPITALIZED(CAPITALIZEDEvent<TExtensions>),
}

pub async fn playground_types_contract(
    network: &str,
) -> RindexerPlaygroundTypesGenInstance<Arc<RindexerProvider>, AnyNetwork> {
    let address: Address =
        "0x1234567890abcdef1234567890abcdef12345678".parse().expect("Invalid address");
    RindexerPlaygroundTypesGen::new(
        address,
        get_provider_cache_for_network(network).await.get_inner_provider(),
    )
}

pub async fn decoder_contract(
    network: &str,
) -> RindexerPlaygroundTypesGenInstance<Arc<RindexerProvider>, AnyNetwork> {
    if network == "base" {
        RindexerPlaygroundTypesGen::new(
            // do not care about address here its decoding makes it easier to handle ValueOrArray
            Address::ZERO,
            get_provider_cache_for_network(network).await.get_inner_provider(),
        )
    } else {
        panic!("Network not supported");
    }
}

impl<TExtensions> PlaygroundTypesEventType<TExtensions>
where
    TExtensions: 'static + Send + Sync,
{
    pub fn topic_id(&self) -> &'static str {
        match self {
            PlaygroundTypesEventType::BasicTypes(_) => {
                "0x949005f12d34a124abc414bb13fdf869260066a1704bb8f7e32f8ffe169e7aa0"
            }
            PlaygroundTypesEventType::BytesTypes(_) => {
                "0x740ea88bdfda41383d772ab56024934e34bf043c79a814b874b6b4045f9e826e"
            }
            PlaygroundTypesEventType::RegularWidthSignedIntegers(_) => {
                "0xfceaa4cb39e7e2b2d01fbbdda78859ab85d789c7d81b36eaf854dd5680cad2c7"
            }
            PlaygroundTypesEventType::RegularWidthUnsignedIntegers(_) => {
                "0x879a04169914c4a3fcadfb6e49501ab589b87df84079c21d0ac006230e58c343"
            }
            PlaygroundTypesEventType::IrregularWidthSignedIntegers(_) => {
                "0x080c14016442a8f4551192a32cfc9e215ee332be42b31227d9496f60b6db077d"
            }
            PlaygroundTypesEventType::IrregularWidthUnsignedIntegers(_) => {
                "0xc2e0372d5c143778c98a111177c83df6fb3289d997c12357e2c801e2b20e8212"
            }
            PlaygroundTypesEventType::Under_Score(_) => {
                "0xd92ac10c3cc15a122225739d30f30a735b76cf1f84844b635e11c43fad314d06"
            }
            PlaygroundTypesEventType::CAPITALIZED(_) => {
                "0x4f0775f31571ef6452b391e8cb0c3e63d9fd458b785799d7c3a0a8afec87ca01"
            }
        }
    }

    pub fn event_name(&self) -> &'static str {
        match self {
            PlaygroundTypesEventType::BasicTypes(_) => "BasicTypes",
            PlaygroundTypesEventType::BytesTypes(_) => "BytesTypes",
            PlaygroundTypesEventType::RegularWidthSignedIntegers(_) => "RegularWidthSignedIntegers",
            PlaygroundTypesEventType::RegularWidthUnsignedIntegers(_) => {
                "RegularWidthUnsignedIntegers"
            }
            PlaygroundTypesEventType::IrregularWidthSignedIntegers(_) => {
                "IrregularWidthSignedIntegers"
            }
            PlaygroundTypesEventType::IrregularWidthUnsignedIntegers(_) => {
                "IrregularWidthUnsignedIntegers"
            }
            PlaygroundTypesEventType::Under_Score(_) => "Under_Score",
            PlaygroundTypesEventType::CAPITALIZED(_) => "CAPITALIZED",
        }
    }

    pub fn contract_name(&self) -> String {
        "PlaygroundTypes".to_string()
    }

    async fn get_provider(&self, network: &str) -> Arc<JsonRpcCachedProvider> {
        get_provider_cache_for_network(network).await
    }

    fn decoder(
        &self,
        network: &str,
    ) -> Arc<dyn Fn(Vec<B256>, Bytes) -> Arc<dyn Any + Send + Sync> + Send + Sync> {
        let decoder_contract = decoder_contract(network);

        match self {
            PlaygroundTypesEventType::BasicTypes(_) => Arc::new(
                move |topics: Vec<B256>, data: Bytes| match BasicTypesData::decode_raw_log(
                    topics,
                    &data[0..],
                ) {
                    Ok(event) => {
                        let result: BasicTypesData = event;
                        Arc::new(result) as Arc<dyn Any + Send + Sync>
                    }
                    Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                },
            ),

            PlaygroundTypesEventType::BytesTypes(_) => Arc::new(
                move |topics: Vec<B256>, data: Bytes| match BytesTypesData::decode_raw_log(
                    topics,
                    &data[0..],
                ) {
                    Ok(event) => {
                        let result: BytesTypesData = event;
                        Arc::new(result) as Arc<dyn Any + Send + Sync>
                    }
                    Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                },
            ),

            PlaygroundTypesEventType::RegularWidthSignedIntegers(_) => {
                Arc::new(move |topics: Vec<B256>, data: Bytes| {
                    match RegularWidthSignedIntegersData::decode_raw_log(topics, &data[0..]) {
                        Ok(event) => {
                            let result: RegularWidthSignedIntegersData = event;
                            Arc::new(result) as Arc<dyn Any + Send + Sync>
                        }
                        Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                    }
                })
            }

            PlaygroundTypesEventType::RegularWidthUnsignedIntegers(_) => {
                Arc::new(move |topics: Vec<B256>, data: Bytes| {
                    match RegularWidthUnsignedIntegersData::decode_raw_log(topics, &data[0..]) {
                        Ok(event) => {
                            let result: RegularWidthUnsignedIntegersData = event;
                            Arc::new(result) as Arc<dyn Any + Send + Sync>
                        }
                        Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                    }
                })
            }

            PlaygroundTypesEventType::IrregularWidthSignedIntegers(_) => {
                Arc::new(move |topics: Vec<B256>, data: Bytes| {
                    match IrregularWidthSignedIntegersData::decode_raw_log(topics, &data[0..]) {
                        Ok(event) => {
                            let result: IrregularWidthSignedIntegersData = event;
                            Arc::new(result) as Arc<dyn Any + Send + Sync>
                        }
                        Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                    }
                })
            }

            PlaygroundTypesEventType::IrregularWidthUnsignedIntegers(_) => {
                Arc::new(move |topics: Vec<B256>, data: Bytes| {
                    match IrregularWidthUnsignedIntegersData::decode_raw_log(topics, &data[0..]) {
                        Ok(event) => {
                            let result: IrregularWidthUnsignedIntegersData = event;
                            Arc::new(result) as Arc<dyn Any + Send + Sync>
                        }
                        Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                    }
                })
            }

            PlaygroundTypesEventType::Under_Score(_) => Arc::new(
                move |topics: Vec<B256>, data: Bytes| match Under_ScoreData::decode_raw_log(
                    topics,
                    &data[0..],
                ) {
                    Ok(event) => {
                        let result: Under_ScoreData = event;
                        Arc::new(result) as Arc<dyn Any + Send + Sync>
                    }
                    Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                },
            ),

            PlaygroundTypesEventType::CAPITALIZED(_) => Arc::new(
                move |topics: Vec<B256>, data: Bytes| match CAPITALIZEDData::decode_raw_log(
                    topics,
                    &data[0..],
                ) {
                    Ok(event) => {
                        let result: CAPITALIZEDData = event;
                        Arc::new(result) as Arc<dyn Any + Send + Sync>
                    }
                    Err(error) => Arc::new(error) as Arc<dyn Any + Send + Sync>,
                },
            ),
        }
    }

    pub async fn register(self, manifest_path: &PathBuf, registry: &mut EventCallbackRegistry) {
        let rindexer_yaml = read_manifest(manifest_path).expect("Failed to read rindexer.yaml");
        let topic_id = self.topic_id();
        let contract_name = self.contract_name();
        let event_name = self.event_name();

        let contract_details = rindexer_yaml
            .all_contracts()
            .iter()
            .find(|c| c.name == contract_name)
            .unwrap_or_else(|| {
                panic!(
                    "Contract {} not found please make sure its defined in the rindexer.yaml",
                    contract_name
                )
            })
            .clone();

        let index_event_in_order = contract_details
            .index_event_in_order
            .as_ref()
            .map_or(false, |vec| vec.contains(&event_name.to_string()));

        // Expect providers to have been initialized, but it's an async init so this should
        // be fast but for correctness we must await each future.
        let mut providers = HashMap::new();
        for n in contract_details.details.iter() {
            let provider = self.get_provider(&n.network).await;
            providers.insert(n.network.clone(), provider);
        }

        let contract = ContractInformation {
            name: contract_details.before_modify_name_if_filter_readonly().into_owned(),
            details: contract_details
                .details
                .iter()
                .map(|c| NetworkContract {
                    id: generate_random_id(10),
                    network: c.network.clone(),
                    cached_provider: providers
                        .get(&c.network)
                        .expect("must have a provider")
                        .clone(),
                    decoder: self.decoder(&c.network),
                    indexing_contract_setup: c.indexing_contract_setup(manifest_path),
                    start_block: c.start_block,
                    end_block: c.end_block,
                    disable_logs_bloom_checks: rindexer_yaml
                        .networks
                        .iter()
                        .find(|n| n.name == c.network)
                        .map_or(false, |n| n.disable_logs_bloom_checks.unwrap_or_default()),
                })
                .collect(),
            abi: contract_details.abi,
            reorg_safe_distance: contract_details.reorg_safe_distance.unwrap_or_default(),
        };

        let callback: Arc<
            dyn Fn(Vec<EventResult>) -> BoxFuture<'static, EventCallbackResult<()>> + Send + Sync,
        > = match self {
            PlaygroundTypesEventType::BasicTypes(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::BytesTypes(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::RegularWidthSignedIntegers(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::RegularWidthUnsignedIntegers(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::IrregularWidthSignedIntegers(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::IrregularWidthUnsignedIntegers(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::Under_Score(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }

            PlaygroundTypesEventType::CAPITALIZED(event) => {
                let event = Arc::new(event);
                Arc::new(move |result| {
                    let event = Arc::clone(&event);
                    async move { event.call(result).await }.boxed()
                })
            }
        };

        registry.register_event(EventCallbackRegistryInformation {
            id: generate_random_id(10),
            indexer_name: "RindexerPlayground".to_string(),
            event_name: event_name.to_string(),
            index_event_in_order,
            topic_id: topic_id.parse::<B256>().unwrap(),
            contract,
            callback,
        });
    }
}
