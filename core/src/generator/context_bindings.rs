use alloy::rpc::types::ValueOrArray;

use super::networks_bindings::network_provider_fn_name;
use crate::{
    helpers::{camel_to_snake, to_pascal_case},
    manifest::{
        contract::{Contract, ContractDetails},
        network::Network,
    },
    types::code::Code,
    StringOrArray,
};

fn generate_contract_code(
    contract_name: &str,
    contract_details: &ContractDetails,
    abi_location: &str,
    network: &Network,
) -> Code {
    if let Some(address) = contract_details.address() {
        match address {
            ValueOrArray::Value(address) => {
                let contract_address = format!("{:?}", address);
                let code = format!(
                    r#"
                        sol!(
                            #[derive(Debug)]
                            #[sol(rpc, all_derives)]
                            {contract_name}{network_suffix},
                            "{contract_path}"
                        );

                        pub async fn {contract_fn_name}_{network_fn_name}_contract() -> {contract_name}{network_suffix}::{contract_name}{network_suffix}Instance<Arc<RindexerProvider>> {{
                            let address: Address = "{contract_address}"
                                .parse()
                                .expect("Invalid address");

                            {contract_name}{network_suffix}::new(address, {network_fn_name}().await.clone())
                        }}
                    "#,
                    contract_name = contract_name,
                    network_suffix = to_pascal_case(&network.name),
                    contract_fn_name = camel_to_snake(contract_name),
                    contract_address = contract_address,
                    network_fn_name = network_provider_fn_name(network),
                    contract_path = abi_location
                );
                Code::new(code)
            }
            // let them pass in the address
            ValueOrArray::Array(_) => {
                let code = format!(
                    r#"
                         sol!(
                            #[derive(Debug)]
                            #[sol(rpc, all_derives)]
                            {contract_name}{network_suffix},
                            "{contract_path}"
                        );

                        pub fn {contract_fn_name}_contract(address: Address) -> {contract_name}{network_suffix}::{contract_name}{network_suffix}Instance<Arc<RindexerProvider> {{
                            {contract_name}{network_suffix}::new(address, {network_fn_name}().clone())
                        }}
                    "#,
                    contract_name = contract_name,
                    network_suffix = to_pascal_case(&network.name),
                    contract_fn_name = camel_to_snake(contract_name),
                    network_fn_name = network_provider_fn_name(network),
                    contract_path = abi_location
                );
                Code::new(code)
            }
        }
    } else {
        Code::blank()
    }
}

fn generate_contracts_code(contracts: &[Contract], networks: &[Network]) -> Code {
    let network_imports: Vec<String> = networks.iter().map(network_provider_fn_name).collect();
    let mut output = Code::new(format!(
        r#"
        /// THIS IS A GENERATED FILE. DO NOT MODIFY MANUALLY.
        ///
        /// This file was auto generated by rindexer - https://github.com/joshstevens19/rindexer.
        /// Any manual changes to this file will be overwritten.
        
        use super::networks::{{{}}};
        use std::sync::Arc;
        use rindexer::provider::RindexerProvider;
        use alloy::primitives::Address;
        use alloy::sol;
        "#,
        network_imports.join(", ")
    ));

    let mut code = Code::blank();

    for contract in contracts {
        for details in &contract.details {
            if let Some(network) = networks.iter().find(|&n| n.name == details.network) {
                if let StringOrArray::Single(abi_path) = &contract.abi {
                    code.push_str(&generate_contract_code(
                        &contract.name,
                        details,
                        abi_path,
                        network,
                    ));
                } else {
                    panic!("Multiple ABIs not supported yet on global contracts");
                }
            }
        }
    }

    output.push_str(&code);

    output
}

pub fn generate_context_code(contracts: &Option<Vec<Contract>>, networks: &[Network]) -> Code {
    if let Some(contracts) = contracts {
        generate_contracts_code(contracts, networks)
    } else {
        Code::blank()
    }
}
